## 피로도

### 문제 풀이
1. visited 배열과 dfs 재귀를 이용해 탐색한다.
2. 함수 호출 때마다 카운트 하며 max 구하기


## N-Queen
- 처음에 대각선과 가로, 세로를 이동할 수 있다는 것을 한 칸씩만 이동할 수 있다고 잘못 이해했다.

- 2차원 배열로 풀려고 시도했다가, 1차원 배열로 풀 수 있다는 힌트를 보고 1차원 배열로 구현했다.

### 문제 풀이
1. board[] 1차원 배열을 이용한다. 여기서 index는 row, 값은 col 이다.
2. 1차원 배열을 돌며, 각 행의 col을 배열의 값으로 넣는다.
3. 다음 행에서 어떤 col 이 유효한지를 체크하는 것은, 배열을 순회하며
   1. board[] 배열에 같은 번호가 있는지
   2. 대각선의 기울기 1이 나오는 값이 있는지
  두 가지를 체크한다.


## 양궁 대회

### 문제 풀이
1. lion의 양궁 점수 배열을 백트래킹으로 구현한다.
2. 완성된 lion 양궁 배열을 apeach와 비교해 점수를 구한다.
3. 점수가 lion이 큰 경우, lion과 apeach의 점수차를 구하고 최대 값을 갱신한다.
4. 최대 값인 경우를 배열에 저장한다.

### 유의점
백트래킹 생성 시 아래처럼 구현을 했더니 시간 초과가 났다.

```java
for(int i = 0; i<11; i++){
    if(info[i]<lion[i]) continue;
    lion[i]++;
    backTracking(n, count+1, info, lion);
    lion[i]--;
}
```
위의 경우에는 모든 인덱스를 한번씩 방문하게 된다.


```java
for(int i = 0; i<11 && info[i]>=lion[i]; i++){
    lion[i]++;
    backTracking(n, count+1, info, lion);
    lion[i]--;
}
```
위 경우에는 아예 해당 인덱스에 접근하지 않고 건너뛰게 된다. 불필요한 탐색이 줄어 시간 복잡도에서 유리히다.