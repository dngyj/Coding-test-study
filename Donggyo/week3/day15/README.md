## 양과 늑대
- 트리를 순회하며 탐색을 해야하는데, 포인트는 되돌아올 수 있는 탐색을 해야한다.

- 방문한 점을 다시 방문하기 위한 구현 방법은 내가 아는 범위에서는 2가지가 있다.
  1. dfs에 매개변수로 visited 배열을 가지고 다니는 것
  2. 비트마스킹을 활용한 bfs
    > (“ㅗ”, “ㅓ”, “ㅏ”, “ㅜ” 같은 탐색의 경우는 제외)

이번 기회에 비트마스킹을 학습하기 위해, 2번 방식으로 문제를 풀이했다.

### 비트마스킹
비트 마스킹은 정수의 이진수 표현을 자료구조로 쓰는 기법이다. 이진수는 0과 1을 사용하고, 각 비트는 두 가지 상태(켜짐/꺼짐)만을 표현할 수 있다.

#### 비트마스킹을 사용하는 이유

1. 단순한 visited 배열로 해결이 어려운 문제를 해결할 수 있음

2. 탐색 경로를 한 개의 정수로 표현할 수 있어 메모리 절약 가능 (특히 좋음)

3. 연산 속도가 빠름 (O(1))

4. 코드가 간결해짐

#### 비트 연산자
비트마스크를 사용하려면, 비트 연산자를 숙지해야한다. a와 b를 통해 c를 만든다고 할 때, a와 b를 한 bit 씩 비교하면서 c의 해당 비트를 만든다. 아래의 5가지 연산이 있다.

> AND, OR, XOR, NOT, SHIFT

- AND(&) : 대응하는 두 비트가 모두 1일 때, 1 반환

- OR(|) : 대응하는 두 비트 중 모두 1이거나 하나라도 1일때, 1 반환

- XOR(^) : 대응하는 두 비트가 서로 다를 때, 1 반환

- NOT(~) : 비트 값 반전하여 반환

- SHIFT(>>, <<) : 왼쪽 혹은 오른쪽으로 비트 옮겨 반환

  ```
  [왼  쪽] 0001 → 0010 → 0100 → 1000 : 1 → 2 → 4 → 8
  [오른쪽] 1000 → 0100 → 0010 → 0001 : 8 → 4 → 2 → 1
  ```

이 정도만 잡고 넘어가자. 어차피 직접 푸는게 아니면 다 까먹더라.

<br>

### 비트마스킹을 양과 늑대에 적용하기
핵심 아이디어는 현재 위치한 노드 하나만 저장하는 것이 아니라, 방문한 모든 노드의 상태를 저장하며 탐색하는 것!

예를 들어 일반적인 BFS에서는 1 → 3 경로를 탐색할 때, 3만 저장하지만, 비트마스킹을 활용하면 0001010 형태로 1과 3을 방문했다는 정보를 유지할 수 있다.

<br>

### 문제 풀이
1. visited를 통한 방문처리
```java
boolean[] visited = new boolean[1 << V];
```
- `1 << V`는 `2^V` 크기의 배열을 생성하는 연산.
- 각 인덱스는 비트마스크이다. 방문한 경로를 추적한다. `visited[bitmask]`
- 예를 들어, 비트마스크 0001010 이라면, 1번과 3번 노드를 방문했다는 의미이다.

2. 경로 방문 여부 확인
```java
int cur = q.poll();
if (visited[cur]) {
    continue;
}
visited[cur] = true;
```
- 지금까지 지나온 노드들을 바탕으로 방문 여부를 체크한다.
- 예를 들어 001001 이면 0번 노드와 3번 노드를 방문한 경로이고, 같은 경로로 들어오면 더이상 탐색하지 않음.

3. `1 << i & cur` 연산을 통한 노드 체크
```java
for (int i = 0; i < n; i++) {
    if ((1 << i & cur) == 0) {
        continue;
    }
}
```
- `(1 << i & cur)`는 now 비트마스크에서 i번 비트가 1인지를 확인하는 연산이다.
- 해당 값이 0이라면, 방문하지 않았다는 것.
- 예를 들어, 1001 이라면 2번째 노드는 0이니 방문하지 않은 노드임.


나머지는 주석으로 대체